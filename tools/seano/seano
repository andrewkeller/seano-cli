#!/usr/bin/env python
"""
seano
CE (release) Notes
Interrogates and manipulates a CE Release Notes (seano) database.
"""

from pyseano.cmd import *
import argparse
import logging
import os

log = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--verbose', '-v', action='count', default=0, help='Increase verbosity level')
    subparsers = parser.add_subparsers(help='verb')

    def add_db_args(subparser, needsExtendedInfo=False):
        subparser.add_argument('--db', action='store', default=os.environ.get('SEANO_DB_PATH', ''),
                               help='The path to the database; overrides the SEANO_DB_PATH environment variable if set')
        if not needsExtendedInfo: return
        subparser.add_argument('--current-version', metavar='NAME', action='store', default='',
                               help='The name of the current version; defaults to "HEAD"; ' +
                                    "cannot be deduced automatically because seano doesn't want to be responsible " +
                                    'for that kind of logic.')

    subparser = subparsers.add_parser('init', help='Initialize a new release notes database')
    subparser.set_defaults(func=make_new_release_notes_db)
    add_db_args(subparser)

    subparser = subparsers.add_parser('new', help='Create a new release note and edit it')
    subparser.set_defaults(func=make_new_release_notes)
    add_db_args(subparser)
    subparser.add_argument('-n', action='store', dest='count', default=1, help='Number of new notes to create')

    subparser = subparsers.add_parser('edit', help='Identifies and edits the latest created relase note')
    subparser.set_defaults(func=edit_latest_release_note)
    add_db_args(subparser)
    subparser.add_argument('--include-wip', '-w', action='store_true', default=False,
                           help='When no patterns are provided, the default behavior is to search for notes that ' +
                                'have not been committed in the repository yet.  When one or more patterns are ' +
                                'provided, that behavior is disabled.  This option turns that back on.')
    subparser.add_argument('--include-modified', '-m', action='store_true', default=False,
                           help='Modified files (files edited within a range, but added previously), are ' +
                                'universally ignored when selecting files to edit, whether you supplied a pattern ' +
                                'or not.  This option modifies the file selection process to include modified files.')
    subparser.add_argument('patterns', metavar='PATTERN', nargs='*', default=[],
                           help='Instead of selecting works-in-progress (uncommitted notes), search for notes based ' +
                                'on a pattern.  The pattern may be the beginning of a note ID, or it may be a ' +
                                'commit ID or range in the underlying repository, from which we auto-detect added ' +
                                'notes.')

    subparser = subparsers.add_parser('hash', help='Returns an arbitrary string that changes with all database '+
                                      'modifications; used by build systems to properly support incremental builds')
    subparser.set_defaults(func=hash_release_notes_db)
    add_db_args(subparser, True)

    subparser = subparsers.add_parser('query', help='Compiles release notes from the given database')
    subparser.set_defaults(func=query_release_notes)
    add_db_args(subparser, True)
    subparser.add_argument('--out', action='store', required=True, help='Output file; use a single hyphen for stdout')

    subparser = subparsers.add_parser('rekey', help='Move an existing note a new ID')
    subparser.set_defaults(func=rekey_release_note)
    add_db_args(subparser)
    subparser.add_argument('uid', action='store', help='The ID of the note you want to re-key')

    ns = parser.parse_args()

    logging.basicConfig(level=
        {
            0 : logging.INFO,
            1 : logging.DEBUG,
        }.get(
            min(max(ns.verbose, 0), 1)
        ))

    log.debug('Arguments: %s', ns)

    kwargs = dict(vars(ns))
    del kwargs['func']
    del kwargs['verbose']
    ns.func(**kwargs)


if __name__ == '__main__':
    main()
